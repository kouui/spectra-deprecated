------------------------------------------------------------------------------------------------------------------------------------------------
unit [1E-6 sec] |     numpy     |      nj       |    nj+fas     |    nj+par     |  nj+fas+par   |      vec      |   vec+enum    |    vec+par
------------------------------------------------------------------------------------------------------------------------------------------------
n=10            |     794.7     |      80.0     |      80.3     |   20021.9     |   20645.5     |       4.4     |       4.1     |     108.5
n=100           |    1653.0     |     368.2     |     370.2     |   21771.1     |   22452.1     |      11.0     |      10.0     |     147.2
n=1000          |    4367.3     |    3318.5     |    3353.9     |   24699.9     |   24783.7     |      35.9     |      34.3     |     149.2
n=10000         |   35085.9     |   33989.0     |   33495.6     |   50902.3     |   51250.9     |     299.8     |     296.2     |     279.5
n=100000        |  363899.5     |  368860.8     |  366383.6     |  262907.0     |  263322.7     |    3084.9     |    3058.4     |    1828.0
------------------------------------------------------------------------------------------------------------------------------------------------

Conclusion:
  1. numba.vectorize is really fast
  2. using Enum.mem.value in numba.vectorize function seems good
  3. use parallel flag only when the number of points is extreamly large (>=100x100x100)
  4. numba.njit is bad?! even slower than numpy when number of points gets larger
  5. fastmath does nothing?
