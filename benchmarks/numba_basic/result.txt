------------------------------------------------------------------------------------------------------------------------------------------------
unit [1E-6 sec] |     numpy     |      nj       |    nj+fas     |    nj+par     |  nj+fas+par   |      vec      |   vec+enum    |    vec+par
------------------------------------------------------------------------------------------------------------------------------------------------
n=10            |     804.8     |      90.4     |      76.9     |   21556.8     |   39489.8     |       5.3     |       4.5     |     234.2
n=100           |    2250.4     |     762.9     |     823.9     |   55197.2     |   37852.3     |      10.9     |      10.1     |     163.0
n=1000          |    6528.8     |    3302.8     |    3377.3     |   24574.2     |   26004.9     |      61.0     |      49.5     |     139.2
n=10000         |   35017.2     |   33960.1     |   33421.1     |   52338.7     |   50083.0     |     299.6     |     293.8     |     283.1
n=100000        |  357852.8     |  367358.1     |  361847.6     |  259128.0     |  269675.9     |    3062.8     |    3051.8     |    1736.2
------------------------------------------------------------------------------------------------------------------------------------------------

Conclusion:
1. numba.vectorize is really fast
2. using Enum.mem.value in numba.vectorize function seems good
3. use parallel flag only when the number of points is extreamly large (>=100x100x100)
4. numba.njit is bad?! even slower than numpy when number of points gets larger
5. fastmath does nothing?
